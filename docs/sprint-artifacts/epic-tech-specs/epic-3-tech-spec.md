# Epic 3: Timeline Visualization - Technical Specification

**Epic ID:** 3
**Epic Title:** Timeline Visualization
**Date:** 2025-11-30
**Author:** Generated by Epic Tech Context Specialist

---

## 1. Epic Overview

### 1.1 Description

Epic 3 delivers the hero feature of AI Obituaries: an interactive scatter plot timeline visualization that displays obituaries as data points plotted against time. This is the core differentiator that transforms a simple list of skepticism claims into a compelling visual narrative where users can see the pattern of AI doubt across time.

The visualization uses Visx for low-level SVG control, Motion for 60fps animations, and implements a "Contextual Scatter Plot" pattern where obituary dots are colored by category and distributed using a deterministic jitter algorithm for visual clarity.

### 1.2 Business Value and Goals

- **Visual Proof of Pattern:** The timeline makes the recurring cycle of AI skepticism undeniable - seeing 50+ data points clustered over time tells the story more powerfully than any list
- **Engagement Through Exploration:** Interactive pan, zoom, hover, and click interactions encourage users to explore and discover individual claims
- **Shareability:** Dense clusters during controversy periods become shareable moments (e.g., "look at all the doom predictions during ChatGPT launch")
- **Professional Credibility:** Epoch AI-inspired visualization design conveys data journalism credibility, not novelty site aesthetics
- **Accessibility:** Alternative table view and keyboard navigation ensure the visualization is usable by everyone

### 1.3 Functional Requirements Covered

| FR ID | Requirement | Story |
|-------|-------------|-------|
| FR7 | System displays obituaries on an interactive chronological timeline | 3.1, 3.2 |
| FR8 | Users can scroll/pan the timeline horizontally to navigate through time | 3.3 |
| FR9 | Users can zoom in/out on timeline to adjust time scale granularity | 3.4 |
| FR10 | Timeline displays density visualization showing clusters of obituaries | 3.5 |
| FR11 | Users can hover on timeline data points to see preview tooltips | 3.6 |
| FR12 | Users can click timeline data points to open obituary detail modal | 3.7 |
| FR46 | Timeline renders smoothly without jank during interaction | 3.8 |
| FR47 | Animations run at 60fps | 3.8 |

### 1.4 Scope

**In-Scope (8 Stories):**
- Story 3.1: Scatter Plot Foundation (Visx setup, container, axes)
- Story 3.2: Timeline Data Points (category-colored dots with jitter positioning)
- Story 3.3: Horizontal Scroll/Pan (drag to navigate, momentum scrolling)
- Story 3.4: Zoom Functionality (scroll wheel/pinch zoom, zoom controls)
- Story 3.5: Density Visualization (overlapping glow, cluster badges)
- Story 3.6: Hover Tooltips (preview card on hover with delay)
- Story 3.7: Click to Modal (open obituary detail in side sheet)
- Story 3.8: Animation Polish (60fps, reduced motion support, performance)

**Out-of-Scope:**
- Category filtering UI (Epic 4) - though visualization must accept filter state
- Mobile hybrid view with density bar (Epic 5)
- Alternative table view (Epic 6)
- Keyboard navigation for timeline (Epic 6)
- Screen reader accessibility for timeline (Epic 6)
- Contextual Y-axis modes (market, capability, agi) - initial implementation uses "spread" mode only

### 1.5 Dependencies and Prerequisites

**Epic Dependencies:**
- Epic 1 complete (Foundation)
  - Sanity CMS integration with queries
  - Design system with Deep Archive theme and category colors
  - Layout shell with Header/Footer
- Epic 2 Stories 2.1-2.4 complete:
  - Story 2.1: Count display (homepage structure)
  - Story 2.4: Obituary context component (reused in modal)

**External Dependencies:**
- Visx packages: `@visx/scale`, `@visx/axis`, `@visx/shape`, `@visx/group`, `@visx/tooltip`, `@visx/responsive`
- Motion library for animations
- shadcn/ui Sheet component for modal
- Obituary data in Sanity CMS (at least 10+ entries for meaningful visualization)

---

## 2. Technical Context

### 2.1 Relevant Architecture Decisions

| ADR | Decision | Impact on Epic 3 |
|-----|----------|------------------|
| ADR-002 | Visx over vis-timeline | Full control over scatter plot design, category-colored dots, contextual Y-axis |
| ADR-003 | Contextual Y-Axis Pattern | Y-axis adapts based on mode (spread for MVP, market/capability/agi for future) |
| ADR-004 | URL State with nuqs | Filter state from URL (Epic 4) will be passed to visualization |

### 2.2 Technology Stack for Epic 3

| Technology | Version | Purpose in Epic 3 |
|------------|---------|-------------------|
| Visx | 3.12.0 | Core visualization primitives (scales, axes, shapes) |
| Motion | 12.9.2 | 60fps animations, spring physics, gesture handling |
| shadcn/ui | 3.5.0 | Sheet component for modal, Tooltip primitives |
| React | 19.x | Client components with hooks for state management |
| TypeScript | 5.x | Type-safe visualization props and data |

### 2.3 Project Structure (Epic 3 Additions)

```
src/
├── app/
│   └── page.tsx                    # Modify: Integrate ScatterPlot component
│
├── components/
│   ├── visualization/
│   │   ├── scatter-plot.tsx        # Create: Main timeline component
│   │   ├── scatter-point.tsx       # Create: Individual data point
│   │   ├── axis-time.tsx           # Create: X-axis (time)
│   │   ├── axis-context.tsx        # Create: Y-axis (contextual metric)
│   │   ├── tooltip-card.tsx        # Create: Hover tooltip
│   │   ├── zoom-controls.tsx       # Create: Zoom +/- buttons
│   │   ├── cluster-badge.tsx       # Create: Density cluster indicator
│   │   └── types.ts                # Create: Visualization type definitions
│   │
│   ├── obituary/
│   │   └── obituary-modal.tsx      # Create: Side sheet modal for detail
│   │
│   └── ui/
│       └── sheet.tsx               # Already exists from Epic 1
│
├── lib/
│   ├── hooks/
│   │   ├── use-zoom.ts             # Create: Zoom/pan state management
│   │   └── use-timeline-position.ts # Create: Position persistence
│   │
│   └── utils/
│       ├── scatter-helpers.ts      # Create: Jitter algorithm, Y-value helpers
│       ├── clustering.ts           # Create: Point clustering algorithm
│       └── animation.ts            # Create: Animation presets
│
└── types/
    └── visualization.ts            # Create: Visualization-specific types
```

### 2.4 Integration Points

```
Epic 3 Visualization Data Flow:

┌─────────────────┐
│   Sanity CMS    │
│   (obituaries)  │
└────────┬────────┘
         │ getObituaries() - reuse from Epic 2
         ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Server Component (page.tsx)                   │
│                                                                   │
│  1. Fetch obituaries (already done for list)                      │
│  2. Pass data to ScatterPlot component                            │
└─────────────────────┬─────────────────────────────────────────────┘
                      │ obituaries[]
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Client Components                             │
│                                                                   │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │                    ScatterPlot ('use client')                │ │
│  │                                                              │ │
│  │  State:                                                       │ │
│  │  - zoom: number (scale factor)                               │ │
│  │  - pan: { x: number } (scroll position)                      │ │
│  │  - hoveredId: string | null                                  │ │
│  │  - selectedId: string | null                                 │ │
│  │                                                              │ │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │ │
│  │  │  AxisTime    │  │ AxisContext  │  │ ZoomControls │       │ │
│  │  │  (X-axis)    │  │  (Y-axis)    │  │  (+/- btns)  │       │ │
│  │  └──────────────┘  └──────────────┘  └──────────────┘       │ │
│  │                                                              │ │
│  │  ┌──────────────────────────────────────────────────────┐   │ │
│  │  │              SVG Container (responsive)               │   │ │
│  │  │                                                        │   │ │
│  │  │  {obituaries.map(ob => (                              │   │ │
│  │  │    <ScatterPoint                                       │   │ │
│  │  │      obituary={ob}                                     │   │ │
│  │  │      x={scaleTime(ob.date)}                           │   │ │
│  │  │      y={jitter(ob._id)}                               │   │ │
│  │  │      color={categoryColor(ob.categories[0])}          │   │ │
│  │  │      onHover={setHoveredId}                           │   │ │
│  │  │      onClick={setSelectedId}                          │   │ │
│  │  │    />                                                  │   │ │
│  │  │  ))}                                                   │   │ │
│  │  │                                                        │   │ │
│  │  │  {hoveredId && <TooltipCard obituary={hovered} />}    │   │ │
│  │  │  {clusters.map(c => <ClusterBadge count={c.count} />)}│   │ │
│  │  └──────────────────────────────────────────────────────┘   │ │
│  └──────────────────────────────────────────────────────────────┘ │
│                                                                   │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │                    ObituaryModal (Sheet)                     │ │
│  │                                                              │ │
│  │  - Full claim text                                           │ │
│  │  - Source with link                                          │ │
│  │  - ObituaryContext (reuse from Epic 2)                       │ │
│  │  - "View full page" button                                   │ │
│  │  - CopyButton (reuse from Epic 2)                            │ │
│  └──────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘

Future Integration (Epic 4 - Not implemented in Epic 3):
┌─────────────────┐
│ URL State (nuqs)│ ─── categories[] ───► ScatterPlot
│   ?cat=market   │                       (filter dots)
└─────────────────┘
(Deferred to Epic 4: Category filtering via URL state)
```

---

## 3. Data Models

### 3.1 Visualization Type Definitions

```typescript
// src/types/visualization.ts

import type { Category, ObituarySummary } from './obituary'

/**
 * Y-axis mode for contextual scatter plot.
 * - spread: Default jitter-based distribution for visual clarity
 * - market: Y = NVDA stock price (future)
 * - capability: Y = benchmark score (future)
 * - agi: Y = milestone timeline (future)
 */
export type YAxisMode = 'spread' | 'market' | 'capability' | 'agi'

/**
 * Processed obituary data for visualization.
 * Extends ObituarySummary with computed X/Y coordinates.
 */
export interface VisualizationPoint {
  /** Original obituary data */
  obituary: ObituarySummary
  /** Computed X position (pixels) */
  x: number
  /** Computed Y position (pixels) */
  y: number
  /** Category color (CSS variable reference) */
  color: string
  /** Whether point matches current filters */
  isFiltered: boolean
}

/**
 * Cluster of overlapping points.
 * Created when points are within clustering threshold.
 */
export interface PointCluster {
  /** Unique cluster ID */
  id: string
  /** Center X position */
  x: number
  /** Center Y position */
  y: number
  /** Number of points in cluster */
  count: number
  /** Obituary IDs in cluster */
  obituaryIds: string[]
  /** Primary category (most common in cluster) */
  primaryCategory: Category
}

/**
 * Zoom and pan state for visualization.
 */
export interface ViewState {
  /** Zoom scale factor (0.5 to 5) */
  scale: number
  /** Pan offset X (pixels) */
  translateX: number
  /** Pan offset Y (pixels) */
  translateY: number
}

/**
 * Props for main ScatterPlot component.
 */
export interface ScatterPlotProps {
  /** Obituary data to visualize */
  data: ObituarySummary[]
  /** Y-axis mode (default: 'spread') */
  mode?: YAxisMode
  /** Active category filters (empty = all) */
  activeCategories?: Category[]
  /** Callback when obituary is selected */
  onSelect?: (obituary: ObituarySummary) => void
  /** Initial width (responsive if not provided) */
  width?: number
  /** Height (default: 400) */
  height?: number
}

/**
 * Tooltip display data.
 */
export interface TooltipData {
  /** Obituary being shown */
  obituary: ObituarySummary
  /** Tooltip X position */
  x: number
  /** Tooltip Y position */
  y: number
}
```

### 3.2 Scatter Helper Utilities

```typescript
// src/lib/utils/scatter-helpers.ts

import type { Category } from '@/types/obituary'
import type { YAxisMode } from '@/types/visualization'

/**
 * Category colors as hex values for SVG fill.
 *
 * IMPORTANT: These values MUST match the CSS variables defined in globals.css:
 *   --category-capability: #C9A962
 *   --category-market: #7B9E89
 *   --category-agi: #9E7B7B
 *   --category-dismissive: #7B7B9E
 *
 * If colors change in globals.css, update this mapping accordingly.
 * Alternative: Use getComputedStyle(document.documentElement).getPropertyValue('--category-{name}')
 * for runtime CSS variable lookup (adds complexity but ensures sync).
 */
export const CATEGORY_HEX_COLORS: Record<Category, string> = {
  capability: '#C9A962',  // Gold - matches --category-capability
  market: '#7B9E89',      // Sage - matches --category-market
  agi: '#9E7B7B',         // Rose - matches --category-agi
  dismissive: '#7B7B9E',  // Lavender - matches --category-dismissive
}

/**
 * Deterministic jitter algorithm.
 * Produces consistent Y position for same ID (reproducible across renders).
 *
 * @param id - Unique identifier (obituary._id)
 * @returns Number between 0 and 1 for Y-axis scaling
 */
export function hashToJitter(id: string): number {
  let hash = 0
  for (let i = 0; i < id.length; i++) {
    hash = ((hash << 5) - hash) + id.charCodeAt(i)
    hash = hash & hash // Convert to 32-bit integer
  }
  return (Math.abs(hash) % 100) / 100
}

/**
 * Get Y-axis value based on mode.
 *
 * @param obituary - Obituary with optional context
 * @param mode - Y-axis mode
 * @returns Normalized Y value (0-1) or null if data missing
 */
export function getYValue(
  obituary: { _id: string; context?: { nvdaPrice?: number; benchmarkScore?: number } },
  mode: YAxisMode
): number | null {
  switch (mode) {
    case 'market':
      // NVDA price normalized (assume 0-1500 range)
      return obituary.context?.nvdaPrice
        ? Math.min(obituary.context.nvdaPrice / 1500, 1)
        : null
    case 'capability':
      // Benchmark score normalized (assume 0-100 range)
      return obituary.context?.benchmarkScore
        ? obituary.context.benchmarkScore / 100
        : null
    case 'agi':
      // Milestone - not yet implemented, fall back to jitter
      return hashToJitter(obituary._id)
    case 'spread':
    default:
      return hashToJitter(obituary._id)
  }
}

/**
 * Get color for obituary based on primary category.
 * Uses first category in array.
 *
 * @param categories - Array of categories
 * @returns Hex color string
 */
export function getCategoryColor(categories: Category[]): string {
  const primary = categories[0] || 'capability'
  return CATEGORY_HEX_COLORS[primary]
}
```

### 3.3 Clustering Algorithm

```typescript
// src/lib/utils/clustering.ts

import type { PointCluster } from '@/types/visualization'
import type { ObituarySummary, Category } from '@/types/obituary'

/**
 * Cluster configuration.
 */
export interface ClusterConfig {
  /** Distance threshold in pixels for clustering */
  threshold: number
  /** Minimum points to form a cluster */
  minPoints: number
}

/**
 * Default clustering config.
 * At zoom level 1.0, cluster points within 20px.
 */
export const DEFAULT_CLUSTER_CONFIG: ClusterConfig = {
  threshold: 20,
  minPoints: 5,
}

/**
 * Point with computed position.
 */
interface PositionedPoint {
  obituary: ObituarySummary
  x: number
  y: number
}

/**
 * Compute clusters from positioned points.
 * Uses simple grid-based clustering for performance.
 *
 * @param points - Points with computed positions
 * @param config - Clustering configuration
 * @param zoomScale - Current zoom level (threshold scales with zoom)
 * @returns Array of clusters
 */
export function computeClusters(
  points: PositionedPoint[],
  config: ClusterConfig = DEFAULT_CLUSTER_CONFIG,
  zoomScale: number = 1
): PointCluster[] {
  const effectiveThreshold = config.threshold / zoomScale
  const clusters: PointCluster[] = []
  const assigned = new Set<string>()

  for (const point of points) {
    if (assigned.has(point.obituary._id)) continue

    // Find all nearby points
    const nearby = points.filter(p => {
      if (assigned.has(p.obituary._id)) return false
      const dx = p.x - point.x
      const dy = p.y - point.y
      return Math.sqrt(dx * dx + dy * dy) <= effectiveThreshold
    })

    if (nearby.length >= config.minPoints) {
      // Create cluster
      const obituaryIds = nearby.map(p => p.obituary._id)
      nearby.forEach(p => assigned.add(p.obituary._id))

      // Compute center
      const centerX = nearby.reduce((sum, p) => sum + p.x, 0) / nearby.length
      const centerY = nearby.reduce((sum, p) => sum + p.y, 0) / nearby.length

      // Find primary category
      const categoryCounts = new Map<Category, number>()
      nearby.forEach(p => {
        const cat = p.obituary.categories[0]
        if (cat) {
          categoryCounts.set(cat, (categoryCounts.get(cat) || 0) + 1)
        }
      })
      let primaryCategory: Category = 'capability'
      let maxCount = 0
      categoryCounts.forEach((count, cat) => {
        if (count > maxCount) {
          maxCount = count
          primaryCategory = cat
        }
      })

      clusters.push({
        id: `cluster-${clusters.length}`,
        x: centerX,
        y: centerY,
        count: nearby.length,
        obituaryIds,
        primaryCategory,
      })
    }
  }

  return clusters
}

/**
 * Check if a point is in any cluster.
 */
export function isPointClustered(
  obituaryId: string,
  clusters: PointCluster[]
): boolean {
  return clusters.some(c => c.obituaryIds.includes(obituaryId))
}
```

---

## 4. Component Specifications

### 4.1 ScatterPlot (Main Container)

**File:** `src/components/visualization/scatter-plot.tsx`

**Purpose:** Main timeline visualization component. Manages state for zoom, pan, hover, and selection. Renders SVG with all child components.

**Required data-testid attributes:**
- `data-testid="scatter-plot"` - on the main container element

**Props:**
```typescript
interface ScatterPlotProps {
  data: ObituarySummary[]
  mode?: YAxisMode              // Default: 'spread'
  activeCategories?: Category[] // Empty = show all
  onSelect?: (obituary: ObituarySummary) => void
  height?: number               // Default: 400
}
```

**State:**
```typescript
const [viewState, setViewState] = useState<ViewState>({
  scale: 1,
  translateX: 0,
  translateY: 0,
})
const [hoveredId, setHoveredId] = useState<string | null>(null)
const [selectedId, setSelectedId] = useState<string | null>(null)
const [tooltipData, setTooltipData] = useState<TooltipData | null>(null)
```

**Key Implementation Details:**
- Use `'use client'` directive (requires DOM/interactivity)
- Use `@visx/responsive` `ParentSize` for responsive width
- Compute scales with `useMemo` to avoid recalculation
- Debounce zoom/pan updates (16ms) for performance
- Handle both mouse and touch events for pan/zoom

**Accessibility:**
- `role="img"` with `aria-label="Interactive timeline of AI obituaries"`
- Individual points are focusable (Epic 6)

### 4.2 ScatterPoint (Data Point)

**File:** `src/components/visualization/scatter-point.tsx`

**Purpose:** Individual obituary dot on the timeline. Handles hover/click interactions and visual states.

**Required data-testid attributes:**
- `data-testid="scatter-point"` - on each circle element (enables E2E test selection of points)

**Props:**
```typescript
interface ScatterPointProps {
  obituary: ObituarySummary
  x: number
  y: number
  color: string
  isFiltered: boolean  // false = dim to 20% opacity
  isHovered: boolean
  isClustered: boolean // true = hidden (cluster badge shown instead)
  onMouseEnter: () => void
  onMouseLeave: () => void
  onClick: () => void
}
```

**Visual States:**
| State | Opacity | Scale | Glow |
|-------|---------|-------|------|
| Default | 0.8 | 1.0 | Subtle shadow |
| Hovered | 1.0 | 1.3 | Intensified |
| Filtered out | 0.2 | 1.0 | None |
| Clustered | 0 | - | - (hidden) |

**Implementation:**
```tsx
<motion.circle
  cx={x}
  cy={y}
  r={7}
  fill={color}
  opacity={isFiltered ? (isHovered ? 1 : 0.8) : 0.2}
  style={{
    filter: isHovered ? 'drop-shadow(0 0 6px currentColor)' : 'drop-shadow(0 0 3px currentColor)',
    pointerEvents: isFiltered ? 'auto' : 'none',
  }}
  whileHover={{ scale: 1.3 }}
  transition={{ type: 'spring', stiffness: 300, damping: 20 }}
  onMouseEnter={onMouseEnter}
  onMouseLeave={onMouseLeave}
  onClick={onClick}
/>
```

### 4.3 AxisTime (X-Axis)

**File:** `src/components/visualization/axis-time.tsx`

**Purpose:** Time-based X-axis showing date range. Adapts tick granularity based on zoom level.

**Props:**
```typescript
interface AxisTimeProps {
  scale: ScaleTime<number, number>
  width: number
  height: number      // Y position (bottom of chart area)
  zoomScale: number   // Affects tick density
}
```

**Tick Granularity:**
| Zoom Level | Tick Interval | Format |
|------------|--------------|--------|
| < 0.7 | Year | "2024" |
| 0.7 - 1.5 | Quarter | "Q1 2024" |
| 1.5 - 3.0 | Month | "Jan 2024" |
| > 3.0 | Week | "Jan 15" |

**Implementation:**
- Use `@visx/axis` `AxisBottom`
- Custom tick formatter based on zoom level
- Styled to match Deep Archive theme

### 4.4 TooltipCard

**File:** `src/components/visualization/tooltip-card.tsx`

**Purpose:** Hover tooltip showing obituary preview. Positioned above the hovered point.

**Required data-testid attributes:**
- `data-testid="tooltip-card"` - on the tooltip container element

**Props:**
```typescript
interface TooltipCardProps {
  obituary: ObituarySummary
  x: number
  y: number
  containerBounds: DOMRect
}
```

**Design:**
- Background: `#1C1C24` (--bg-tertiary)
- Border: 1px `#C9A962` (--accent-primary)
- Border radius: 8px
- Max width: 280px
- Shadow: `0 4px 12px rgba(0,0,0,0.3)`

**Content:**
```
"[Claim truncated to 100 chars...]"

Source: Gary Marcus
Mar 14, 2023
```

**Animation:**
```typescript
<motion.div
  initial={{ opacity: 0, scale: 0.95, y: 5 }}
  animate={{ opacity: 1, scale: 1, y: 0 }}
  exit={{ opacity: 0, scale: 0.95 }}
  transition={{ duration: 0.15 }}
>
```

### 4.5 ZoomControls

**File:** `src/components/visualization/zoom-controls.tsx`

**Purpose:** UI controls for zoom level. Shows +/- buttons and optional reset.

**Props:**
```typescript
interface ZoomControlsProps {
  scale: number
  minScale: number    // Default: 0.5
  maxScale: number    // Default: 5
  onZoomIn: () => void
  onZoomOut: () => void
  onReset: () => void
}
```

**Design:**
- Position: Bottom-right corner of visualization
- Style: Floating buttons with backdrop blur
- Disabled state when at min/max

### 4.6 ClusterBadge

**File:** `src/components/visualization/cluster-badge.tsx`

**Purpose:** Visual indicator for clustered points. Shows count badge when multiple obituaries overlap.

**Props:**
```typescript
interface ClusterBadgeProps {
  cluster: PointCluster
  onClick: () => void  // Zooms into cluster
}
```

**Design:**
- Circle: 24px diameter
- Fill: Primary category color with additive glow
- Badge: White text on category color background
- Text: "+N" format

### 4.7 ObituaryModal

**File:** `src/components/obituary/obituary-modal.tsx`

**Purpose:** Side sheet modal showing full obituary details when a point is clicked.

**Required data-testid attributes:**
- `data-testid="obituary-modal"` - on the Sheet/modal container element

**Props:**
```typescript
interface ObituaryModalProps {
  obituary: Obituary | null  // Full obituary data
  isOpen: boolean
  onClose: () => void
}
```

**Content Layout:**
1. Close button (X) in top-right
2. Claim text (Instrument Serif, large)
3. Source with external link
4. Date formatted
5. Category badges
6. Context section (reuse ObituaryContext from Epic 2)
7. Action buttons:
   - "View full page" (primary, navigates to /obituary/[slug])
   - Copy link button (reuse from Epic 2)

**Animation:**
- Slides in from right edge
- 300ms ease-out transition
- Backdrop: dark overlay with blur

**Implementation:**
- Use shadcn/ui Sheet component with `side="right"`
- Fetch full obituary data when opened (if not already loaded)
- Focus trap within modal

---

## 5. API and Data Fetching

### 5.1 Required Sanity Queries

No new queries needed. Epic 3 uses existing queries from Epic 2:

```typescript
// Already exists in src/lib/sanity/queries.ts
export async function getObituaries(): Promise<ObituarySummary[]>
```

### 5.2 Data Flow

1. **Page Load:** Server component fetches `getObituaries()`
2. **Pass to Client:** Data passed as props to `ScatterPlot`
3. **Compute Positions:** Client-side calculation of X/Y coordinates
4. **Render:** SVG rendered with computed positions
5. **Interaction:** Click triggers modal, which may need to fetch full `Obituary` data

### 5.3 Full Obituary Fetch for Modal

When user clicks a point, we need full obituary data (with context):

```typescript
// In ObituaryModal or ScatterPlot
const [fullObituary, setFullObituary] = useState<Obituary | null>(null)

useEffect(() => {
  if (selectedId) {
    getObituaryBySlug(selectedSlug).then(setFullObituary)
  }
}, [selectedId])
```

---

## 6. Animation Presets

### 6.1 Shared Animation Configuration

**File:** `src/lib/utils/animation.ts`

```typescript
import { type Variants, type Transition } from 'motion/react'

/**
 * Standard transition durations (ms).
 */
export const DURATIONS = {
  fast: 0.15,     // 150ms - hover, tooltips
  normal: 0.2,    // 200ms - state changes
  slow: 0.3,      // 300ms - modal open/close
} as const

/**
 * Spring physics for interactive elements.
 */
export const SPRINGS = {
  hover: { type: 'spring', stiffness: 300, damping: 20 } as Transition,
  zoom: { type: 'spring', stiffness: 300, damping: 30 } as Transition,
  pan: { type: 'spring', stiffness: 100, damping: 20 } as Transition,
} as const

/**
 * Fade in animation for elements.
 */
export const fadeIn: Variants = {
  initial: { opacity: 0 },
  animate: { opacity: 1 },
  exit: { opacity: 0 },
}

/**
 * Scale on hover animation.
 */
export const scaleOnHover = {
  whileHover: { scale: 1.1 },
  whileTap: { scale: 0.95 },
  transition: SPRINGS.hover,
}

/**
 * Modal slide-in animation.
 */
export const modalSlideIn: Variants = {
  initial: { x: '100%', opacity: 0 },
  animate: { x: 0, opacity: 1 },
  exit: { x: '100%', opacity: 0 },
}

/**
 * Tooltip appear animation.
 */
export const tooltipAppear: Variants = {
  initial: { opacity: 0, scale: 0.95, y: 5 },
  animate: { opacity: 1, scale: 1, y: 0 },
  exit: { opacity: 0, scale: 0.95 },
}

/**
 * Staggered children animation (for dot entrance).
 */
export const staggerContainer: Variants = {
  animate: {
    transition: {
      staggerChildren: 0.02,
      delayChildren: 0.1,
    },
  },
}

export const staggerItem: Variants = {
  initial: { opacity: 0, scale: 0 },
  animate: { opacity: 0.8, scale: 1 },
}

/**
 * Check for reduced motion preference (one-time static check).
 *
 * USAGE GUIDANCE:
 * - Use shouldReduceMotion() for one-time checks in non-React contexts,
 *   server-side rendering fallbacks, or utility functions that need a
 *   synchronous boolean value.
 * - Use Motion's useReducedMotion() hook in React components for reactive
 *   updates when user preference changes during session. The hook subscribes
 *   to media query changes and triggers re-renders automatically.
 *
 * Example:
 *   // In a React component (preferred):
 *   const shouldReduce = useReducedMotion()
 *
 *   // In a utility function or non-React context:
 *   if (shouldReduceMotion()) { ... }
 */
export function shouldReduceMotion(): boolean {
  if (typeof window === 'undefined') return false
  return window.matchMedia('(prefers-reduced-motion: reduce)').matches
}

/**
 * Get appropriate transition based on motion preference.
 * Note: For React components, prefer using useReducedMotion() hook
 * directly for reactive preference tracking.
 */
export function getTransition(
  key: keyof typeof SPRINGS | keyof typeof DURATIONS
): Transition {
  if (shouldReduceMotion()) {
    return { duration: 0 }
  }
  if (key in SPRINGS) {
    return SPRINGS[key as keyof typeof SPRINGS]
  }
  return { duration: DURATIONS[key as keyof typeof DURATIONS] }
}
```

---

## 7. Hooks

### 7.1 useZoom

**File:** `src/lib/hooks/use-zoom.ts`

**Purpose:** Manage zoom and pan state for the visualization.

```typescript
'use client'

import { useState, useCallback, useRef } from 'react'
import type { ViewState } from '@/types/visualization'

export interface UseZoomOptions {
  minScale?: number     // Default: 0.5
  maxScale?: number     // Default: 5
  initialScale?: number // Default: 1
}

export interface UseZoomReturn {
  viewState: ViewState
  zoomIn: () => void
  zoomOut: () => void
  resetZoom: () => void
  setScale: (scale: number) => void
  setPan: (x: number, y: number) => void
  handleWheel: (event: WheelEvent) => void
  handlePanStart: (event: MouseEvent | TouchEvent) => void
  handlePanMove: (event: MouseEvent | TouchEvent) => void
  handlePanEnd: () => void
  isPanning: boolean
}

export function useZoom(options: UseZoomOptions = {}): UseZoomReturn {
  const {
    minScale = 0.5,
    maxScale = 5,
    initialScale = 1,
  } = options

  const [viewState, setViewState] = useState<ViewState>({
    scale: initialScale,
    translateX: 0,
    translateY: 0,
  })

  const isPanningRef = useRef(false)
  const lastPanPosRef = useRef({ x: 0, y: 0 })

  const zoomIn = useCallback(() => {
    setViewState(prev => ({
      ...prev,
      scale: Math.min(prev.scale * 1.2, maxScale),
    }))
  }, [maxScale])

  const zoomOut = useCallback(() => {
    setViewState(prev => ({
      ...prev,
      scale: Math.max(prev.scale / 1.2, minScale),
    }))
  }, [minScale])

  const resetZoom = useCallback(() => {
    setViewState({
      scale: 1,
      translateX: 0,
      translateY: 0,
    })
  }, [])

  const setScale = useCallback((scale: number) => {
    setViewState(prev => ({
      ...prev,
      scale: Math.max(minScale, Math.min(scale, maxScale)),
    }))
  }, [minScale, maxScale])

  const setPan = useCallback((x: number, y: number) => {
    setViewState(prev => ({
      ...prev,
      translateX: x,
      translateY: y,
    }))
  }, [])

  const handleWheel = useCallback((event: WheelEvent) => {
    event.preventDefault()
    const delta = event.deltaY > 0 ? 0.9 : 1.1
    setViewState(prev => ({
      ...prev,
      scale: Math.max(minScale, Math.min(prev.scale * delta, maxScale)),
    }))
  }, [minScale, maxScale])

  const handlePanStart = useCallback((event: MouseEvent | TouchEvent) => {
    isPanningRef.current = true
    const pos = 'touches' in event
      ? { x: event.touches[0].clientX, y: event.touches[0].clientY }
      : { x: event.clientX, y: event.clientY }
    lastPanPosRef.current = pos
  }, [])

  const handlePanMove = useCallback((event: MouseEvent | TouchEvent) => {
    if (!isPanningRef.current) return
    const pos = 'touches' in event
      ? { x: event.touches[0].clientX, y: event.touches[0].clientY }
      : { x: event.clientX, y: event.clientY }
    const dx = pos.x - lastPanPosRef.current.x
    const dy = pos.y - lastPanPosRef.current.y
    lastPanPosRef.current = pos
    setViewState(prev => ({
      ...prev,
      translateX: prev.translateX + dx,
      translateY: prev.translateY + dy,
    }))
  }, [])

  const handlePanEnd = useCallback(() => {
    isPanningRef.current = false
  }, [])

  return {
    viewState,
    zoomIn,
    zoomOut,
    resetZoom,
    setScale,
    setPan,
    handleWheel,
    handlePanStart,
    handlePanMove,
    handlePanEnd,
    isPanning: isPanningRef.current,
  }
}
```

### 7.2 useTimelinePosition

**File:** `src/lib/hooks/use-timeline-position.ts`

**Purpose:** Persist and restore timeline scroll/zoom position using sessionStorage.

```typescript
'use client'

import { useEffect, useCallback } from 'react'
import type { ViewState } from '@/types/visualization'

const STORAGE_KEY = 'timeline-position'

export interface UseTimelinePositionReturn {
  savePosition: (state: ViewState) => void
  restorePosition: () => ViewState | null
  clearPosition: () => void
}

export function useTimelinePosition(): UseTimelinePositionReturn {
  const savePosition = useCallback((state: ViewState) => {
    try {
      sessionStorage.setItem(STORAGE_KEY, JSON.stringify(state))
    } catch {
      // Ignore storage errors
    }
  }, [])

  const restorePosition = useCallback((): ViewState | null => {
    try {
      const stored = sessionStorage.getItem(STORAGE_KEY)
      if (stored) {
        return JSON.parse(stored) as ViewState
      }
    } catch {
      // Ignore parse errors
    }
    return null
  }, [])

  const clearPosition = useCallback(() => {
    try {
      sessionStorage.removeItem(STORAGE_KEY)
    } catch {
      // Ignore storage errors
    }
  }, [])

  return {
    savePosition,
    restorePosition,
    clearPosition,
  }
}
```

---

## 8. Stories with Acceptance Criteria

### Story 3.1: Scatter Plot Foundation

**As a** visitor,
**I want** to see obituaries plotted on a timeline,
**So that** I can visualize the pattern of AI skepticism over time.

**Acceptance Criteria:**

| # | Given | When | Then |
|---|-------|------|------|
| AC-3.1.1 | Obituary data is loaded | The homepage renders | A scatter plot visualization is displayed |
| AC-3.1.2 | Scatter plot renders | I view the visualization | It takes full width of container with minimum height 400px (desktop), 300px (mobile) |
| AC-3.1.3 | Scatter plot renders | I view the visualization | It has dark background matching `--bg-secondary` with subtle grid lines at year intervals |
| AC-3.1.4 | Scatter plot renders | I view the axes | X-axis represents time (date), Y-axis uses "spread" mode (jitter distribution) |
| AC-3.1.5 | No obituaries exist | Visualization renders | Empty state shows "No obituaries yet" message |

**Technical Notes:**
- Create `src/components/visualization/scatter-plot.tsx` as client component
- Use `@visx/responsive` ParentSize for responsive width
- Use `@visx/scale` scaleTime for X-axis, scaleLinear for Y-axis
- Import only needed Visx packages (tree-shaking)

**Files to Create:**
- `src/components/visualization/scatter-plot.tsx`
- `src/components/visualization/types.ts`
- `src/types/visualization.ts`

---

### Story 3.2: Timeline Data Points

**As a** visitor,
**I want** to see each obituary as a dot on the timeline,
**So that** I can identify individual claims and their timing.

**Acceptance Criteria:**

| # | Given | When | Then |
|---|-------|------|------|
| AC-3.2.1 | Scatter plot is rendered with data | Data points are drawn | Each obituary appears as a 14px diameter circle |
| AC-3.2.2 | Data points render | I view a point | It has category color fill (Gold/Sage/Rose/Lavender) |
| AC-3.2.3 | Data points render | I view points | They have 80% opacity by default with subtle glow |
| AC-3.2.4 | Data points render | I check position | X = date scaled to timeline width, Y = jitter value (deterministic) |
| AC-3.2.5 | Multiple dots overlap | I view the overlap area | Dots create additive brightness effect through glow |

**Technical Notes:**
- Create `src/components/visualization/scatter-point.tsx`
- Use hashToJitter algorithm for deterministic Y position
- CSS filter for glow: `filter: drop-shadow(0 0 4px currentColor)`
- Use Motion for enter animation (staggered fade-in)

**Files to Create:**
- `src/components/visualization/scatter-point.tsx`
- `src/lib/utils/scatter-helpers.ts`

---

### Story 3.3: Horizontal Scroll/Pan

**As a** visitor,
**I want** to scroll the timeline horizontally,
**So that** I can navigate through different time periods.

**Acceptance Criteria:**

| # | Given | When | Then |
|---|-------|------|------|
| AC-3.3.1 | Timeline is wider than viewport | I scroll horizontally (wheel/trackpad/touch) | Timeline pans smoothly with momentum |
| AC-3.3.2 | Pan is in progress | I drag with mouse | Cursor shows "grab" when hovering, "grabbing" when dragging |
| AC-3.3.3 | Timeline is panned | I view edges | Gradient fade at left/right edges indicates more content |
| AC-3.3.4 | Timeline is panned to edge | I try to pan further | Pan is bounded to data extent (can't scroll past first/last obituary) |
| AC-3.3.5 | Pan completes | I release | Momentum continues briefly then decelerates smoothly |

**Technical Notes:**
- Implement pan handler using mouse/touch events
- Use spring physics for momentum via Motion
- Gradient fade via CSS linear-gradient pseudo-elements

**Files to Modify:**
- `src/components/visualization/scatter-plot.tsx`

---

### Story 3.4: Zoom Functionality

**As a** visitor,
**I want** to zoom in and out on the timeline,
**So that** I can see dense clusters or the full picture.

**Acceptance Criteria:**

| # | Given | When | Then |
|---|-------|------|------|
| AC-3.4.1 | Timeline is displayed | I zoom with scroll wheel or pinch | Timeline scale changes smoothly with spring animation |
| AC-3.4.2 | I zoom | I check behavior | Zoom centers on cursor position |
| AC-3.4.3 | I zoom | I check limits | Scale range is 0.5x (zoomed out) to 5x (zoomed in) |
| AC-3.4.4 | I zoom in | I view time axis | More granular markers appear (months, then weeks) |
| AC-3.4.5 | I zoom out | I view dots | Dots cluster/overlap, density glow intensifies |
| AC-3.4.6 | Zoom controls are visible | I use +/- buttons | Zoom increments/decrements in steps |
| AC-3.4.7 | I'm at zoom limit | I view controls | Zoom buttons are disabled at min/max |

**Technical Notes:**
- Create useZoom hook for state management
- Create ZoomControls component
- Use spring physics for animated zoom transitions

**Files to Create:**
- `src/components/visualization/zoom-controls.tsx`
- `src/lib/hooks/use-zoom.ts`

---

### Story 3.5: Density Visualization

**As a** visitor,
**I want** to see where obituaries cluster densely,
**So that** I can identify periods of peak AI skepticism.

**Acceptance Criteria:**

| # | Given | When | Then |
|---|-------|------|------|
| AC-3.5.1 | Multiple obituaries in short time period | Dots overlap or are close | Visual density apparent through brighter glow |
| AC-3.5.2 | Zoom level < 0.7x | I view clusters | Heavy clustering with count badges visible for 5+ dots |
| AC-3.5.3 | Zoom level 0.7x - 1.5x | I view clusters | Some overlap, glow indicates density |
| AC-3.5.4 | Zoom level > 1.5x | I view dots | Dots fully separated |
| AC-3.5.5 | Cluster of 10+ obituaries exists | I view zoomed out | Single glowing dot with badge "+10" |
| AC-3.5.6 | I click a cluster | Click registered | Timeline zooms into that time period (animated) |

**Technical Notes:**
- Create clustering algorithm based on pixel distance
- Dynamic cluster calculation based on zoom level
- Cluster badge component with count display

**Files to Create:**
- `src/lib/utils/clustering.ts`
- `src/components/visualization/cluster-badge.tsx`

---

### Story 3.6: Hover Tooltips

**As a** visitor,
**I want** to see a preview when hovering over a dot,
**So that** I can quickly scan claims without clicking.

**Acceptance Criteria:**

| # | Given | When | Then |
|---|-------|------|------|
| AC-3.6.1 | I hover over a timeline dot | Hover duration exceeds 300ms | Tooltip appears showing claim (100 chars), source, date |
| AC-3.6.2 | Tooltip appears | I view styling | Dark bg (#1C1C24), gold border, 8px radius, 280px max-width |
| AC-3.6.3 | Tooltip appears | I check animation | Fades in (150ms) with slight scale (0.95-1) |
| AC-3.6.4 | I move mouse away | Cursor leaves dot | Tooltip fades out immediately |
| AC-3.6.5 | Dot is hovered | I view dot | Scale 1.3x with intensified glow |
| AC-3.6.6 | Tooltip would go off-screen | I hover near edge | Tooltip flips position to stay visible |

**Technical Notes:**
- Use `@visx/tooltip` or custom tooltip with portal
- Debounce hover (300ms delay before show)
- Position calculation with boundary detection

**Files to Create:**
- `src/components/visualization/tooltip-card.tsx`

---

### Story 3.7: Click to Modal

**As a** visitor,
**I want** to click a dot to see full obituary details,
**So that** I can explore without leaving the timeline context.

**Acceptance Criteria:**

| # | Given | When | Then |
|---|-------|------|------|
| AC-3.7.1 | I click a timeline dot | Click registered | Obituary modal slides in from right |
| AC-3.7.2 | Modal opens | I view content | Full claim, source link, date, category tags, context snapshot |
| AC-3.7.3 | Modal opens | I check buttons | "View full page" and "Copy link" buttons visible |
| AC-3.7.4 | Modal is open | I view animation | 300ms ease-out slide, backdrop with blur |
| AC-3.7.5 | Modal is open | I press Escape | Modal closes |
| AC-3.7.6 | Modal is open | I click backdrop | Modal closes |
| AC-3.7.7 | Modal opens | Focus state | Focus moves to modal, trapped within |
| AC-3.7.8 | Modal closes | Focus state | Focus returns to clicked dot |

**Technical Notes:**
- Use shadcn/ui Sheet with side="right"
- Reuse ObituaryContext component from Epic 2
- Fetch full obituary data when needed

**Files to Create:**
- `src/components/obituary/obituary-modal.tsx`

---

### Story 3.8: Animation Polish

**As a** visitor,
**I want** all timeline interactions to feel smooth and responsive,
**So that** the experience feels polished and professional.

**Acceptance Criteria:**

| # | Given | When | Then |
|---|-------|------|------|
| AC-3.8.1 | Any timeline interaction | Animation occurs | It runs at 60fps without jank |
| AC-3.8.2 | Timeline loads | Dots appear | Staggered fade-in (50ms per dot, max 500ms total) |
| AC-3.8.3 | Performance check | 200+ dots rendered | No frame drops |
| AC-3.8.4 | Performance check | Hover response measured | < 50ms |
| AC-3.8.5 | Performance check | Click response measured | < 100ms |
| AC-3.8.6 | prefers-reduced-motion enabled | Page loads | Animations disabled (zoom, pan momentum, hover scale, glow pulse) |
| AC-3.8.7 | prefers-reduced-motion enabled | Interactions occur | Basic instant state changes still work |

**Specific Animation Timings:**
- Hover state: 150ms ease-out
- Tooltip appear: 150ms ease-out (after 300ms delay)
- Modal open: 300ms ease-out
- Modal close: 200ms ease-in
- Zoom: spring (stiffness: 300, damping: 30)
- Pan momentum: spring (stiffness: 100, damping: 20)

**Technical Notes:**
- Use Motion `motion` components
- Use `useReducedMotion` hook from Motion
- Profile with Chrome DevTools Performance tab
- Create shared animation presets file

**Files to Create:**
- `src/lib/utils/animation.ts`

**Files to Modify:**
- All visualization components (add reduced motion support)

---

## 9. Testing Strategy

### 9.1 Unit Tests

**File:** `tests/unit/lib/utils/scatter-helpers.test.ts`

```typescript
import { describe, it, expect } from 'vitest'
import { hashToJitter, getYValue, getCategoryColor } from '@/lib/utils/scatter-helpers'

describe('hashToJitter', () => {
  it('produces deterministic output for same input', () => {
    expect(hashToJitter('abc')).toBe(hashToJitter('abc'))
  })

  it('produces different values for different inputs', () => {
    expect(hashToJitter('abc')).not.toBe(hashToJitter('xyz'))
  })

  it('returns value between 0 and 1', () => {
    const result = hashToJitter('test-id')
    expect(result).toBeGreaterThanOrEqual(0)
    expect(result).toBeLessThanOrEqual(1)
  })
})

describe('getYValue', () => {
  it('returns jitter for spread mode', () => {
    const result = getYValue({ _id: 'test' }, 'spread')
    expect(result).toBeDefined()
    expect(result).toBeGreaterThanOrEqual(0)
    expect(result).toBeLessThanOrEqual(1)
  })

  it('returns null for market mode without context', () => {
    const result = getYValue({ _id: 'test' }, 'market')
    expect(result).toBeNull()
  })

  it('returns normalized value for market mode with context', () => {
    const result = getYValue(
      { _id: 'test', context: { nvdaPrice: 750 } },
      'market'
    )
    expect(result).toBe(0.5) // 750/1500
  })
})

describe('getCategoryColor', () => {
  it('returns gold for capability', () => {
    expect(getCategoryColor(['capability'])).toBe('#C9A962')
  })

  it('returns first category color for multiple', () => {
    expect(getCategoryColor(['market', 'capability'])).toBe('#7B9E89')
  })

  it('returns default for empty array', () => {
    expect(getCategoryColor([])).toBe('#C9A962')
  })
})
```

**File:** `tests/unit/lib/utils/clustering.test.ts`

```typescript
import { describe, it, expect } from 'vitest'
import { computeClusters, isPointClustered } from '@/lib/utils/clustering'

describe('computeClusters', () => {
  const makePoint = (id: string, x: number, y: number) => ({
    obituary: { _id: id, slug: id, claim: '', source: '', date: '', categories: ['capability'] },
    x,
    y,
  })

  it('returns empty array for sparse points', () => {
    const points = [
      makePoint('1', 0, 0),
      makePoint('2', 100, 100),
      makePoint('3', 200, 200),
    ]
    const clusters = computeClusters(points, { threshold: 20, minPoints: 5 })
    expect(clusters).toHaveLength(0)
  })

  it('creates cluster for nearby points', () => {
    const points = [
      makePoint('1', 10, 10),
      makePoint('2', 12, 12),
      makePoint('3', 8, 8),
      makePoint('4', 11, 9),
      makePoint('5', 9, 11),
    ]
    const clusters = computeClusters(points, { threshold: 20, minPoints: 5 })
    expect(clusters).toHaveLength(1)
    expect(clusters[0].count).toBe(5)
  })
})

describe('isPointClustered', () => {
  it('returns true for clustered point', () => {
    const clusters = [{
      id: 'c1',
      x: 10,
      y: 10,
      count: 5,
      obituaryIds: ['a', 'b', 'c'],
      primaryCategory: 'capability' as const,
    }]
    expect(isPointClustered('a', clusters)).toBe(true)
  })

  it('returns false for non-clustered point', () => {
    const clusters = [{
      id: 'c1',
      x: 10,
      y: 10,
      count: 5,
      obituaryIds: ['a', 'b', 'c'],
      primaryCategory: 'capability' as const,
    }]
    expect(isPointClustered('z', clusters)).toBe(false)
  })
})
```

### 9.2 Component Tests

**File:** `tests/components/visualization/scatter-point.test.tsx`

```typescript
import { render, screen, fireEvent } from '@testing-library/react'
import { describe, it, expect, vi } from 'vitest'
import { ScatterPoint } from '@/components/visualization/scatter-point'

describe('ScatterPoint', () => {
  const defaultProps = {
    obituary: {
      _id: 'test-1',
      slug: 'test-slug',
      claim: 'Test claim',
      source: 'Test source',
      date: '2024-01-01',
      categories: ['capability' as const],
    },
    x: 100,
    y: 50,
    color: '#C9A962',
    isFiltered: true,
    isHovered: false,
    isClustered: false,
    onMouseEnter: vi.fn(),
    onMouseLeave: vi.fn(),
    onClick: vi.fn(),
  }

  it('renders a circle element', () => {
    render(<ScatterPoint {...defaultProps} />)
    const circle = screen.getByRole('img', { hidden: true })
    expect(circle).toBeInTheDocument()
  })

  it('calls onMouseEnter when hovered', () => {
    render(<ScatterPoint {...defaultProps} />)
    const circle = screen.getByRole('img', { hidden: true })
    fireEvent.mouseEnter(circle)
    expect(defaultProps.onMouseEnter).toHaveBeenCalled()
  })

  it('calls onClick when clicked', () => {
    render(<ScatterPoint {...defaultProps} />)
    const circle = screen.getByRole('img', { hidden: true })
    fireEvent.click(circle)
    expect(defaultProps.onClick).toHaveBeenCalled()
  })

  it('has reduced opacity when filtered out', () => {
    render(<ScatterPoint {...defaultProps} isFiltered={false} />)
    const circle = screen.getByRole('img', { hidden: true })
    expect(circle).toHaveStyle({ opacity: '0.2' })
  })
})
```

### 9.3 E2E Tests

**File:** `tests/e2e/timeline.spec.ts`

```typescript
import { test, expect } from '@playwright/test'

test.describe('Timeline Visualization', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/')
  })

  test('displays scatter plot with data points', async ({ page }) => {
    const scatterPlot = page.locator('[data-testid="scatter-plot"]')
    await expect(scatterPlot).toBeVisible()

    const points = page.locator('[data-testid="scatter-point"]')
    await expect(points.first()).toBeVisible()
  })

  test('shows tooltip on hover', async ({ page }) => {
    const point = page.locator('[data-testid="scatter-point"]').first()
    await point.hover()

    // Wait for 300ms hover delay
    await page.waitForTimeout(350)

    const tooltip = page.locator('[data-testid="tooltip-card"]')
    await expect(tooltip).toBeVisible()
  })

  test('opens modal on click', async ({ page }) => {
    const point = page.locator('[data-testid="scatter-point"]').first()
    await point.click()

    const modal = page.locator('[data-testid="obituary-modal"]')
    await expect(modal).toBeVisible()
  })

  test('closes modal on escape', async ({ page }) => {
    const point = page.locator('[data-testid="scatter-point"]').first()
    await point.click()

    const modal = page.locator('[data-testid="obituary-modal"]')
    await expect(modal).toBeVisible()

    await page.keyboard.press('Escape')
    await expect(modal).not.toBeVisible()
  })

  test('zooms with scroll wheel', async ({ page }) => {
    const scatterPlot = page.locator('[data-testid="scatter-plot"]')
    const initialTransform = await scatterPlot.evaluate(el =>
      window.getComputedStyle(el).transform
    )

    await scatterPlot.hover()
    await page.mouse.wheel(0, -100) // Zoom in

    const newTransform = await scatterPlot.evaluate(el =>
      window.getComputedStyle(el).transform
    )

    expect(newTransform).not.toBe(initialTransform)
  })

  test('pans with drag', async ({ page }) => {
    const scatterPlot = page.locator('[data-testid="scatter-plot"]')
    const box = await scatterPlot.boundingBox()

    if (box) {
      await page.mouse.move(box.x + 100, box.y + 100)
      await page.mouse.down()
      await page.mouse.move(box.x + 200, box.y + 100)
      await page.mouse.up()
    }

    // Verify pan occurred by checking translateX changed
    // Implementation detail: would need data-testid on transform container
  })

  test('respects reduced motion preference', async ({ page }) => {
    await page.emulateMedia({ reducedMotion: 'reduce' })
    await page.goto('/')

    const point = page.locator('[data-testid="scatter-point"]').first()
    await point.hover()

    // Tooltip should appear immediately (no animation delay in reduced motion)
    const tooltip = page.locator('[data-testid="tooltip-card"]')
    await expect(tooltip).toBeVisible({ timeout: 100 })
  })
})
```

---

## 10. Non-Functional Requirements

### 10.1 Performance Requirements

| Metric | Target | How to Measure |
|--------|--------|----------------|
| Timeline render (200 dots) | < 100ms | Chrome DevTools Performance |
| Hover response | < 50ms | DevTools interaction timing |
| Click to modal | < 100ms | DevTools interaction timing |
| Zoom animation | 60fps | DevTools FPS meter |
| Pan animation | 60fps | DevTools FPS meter |
| Bundle size (visualization) | < 50KB gzipped | Build output analysis |

### 10.2 Optimization Strategies

1. **Visx Tree-Shaking:** Import only needed modules
   ```typescript
   // Good
   import { scaleTime } from '@visx/scale'
   import { AxisBottom } from '@visx/axis'

   // Bad
   import { scaleTime, AxisBottom } from '@visx/visx'
   ```

2. **Memoization:** Use `useMemo` for scale calculations
   ```typescript
   const xScale = useMemo(() =>
     scaleTime({ domain: [minDate, maxDate], range: [0, width] }),
     [minDate, maxDate, width]
   )
   ```

3. **Debounced Updates:** Debounce zoom/pan state updates
   ```typescript
   const debouncedSetViewState = useMemo(
     () => debounce(setViewState, 16),
     []
   )
   ```

4. **Virtualization (if needed):** For 500+ points, consider react-window
   - Only render points in current viewport
   - Check performance at 200, 500, 1000 points

5. **RequestAnimationFrame:** Batch DOM updates
   ```typescript
   const handleWheel = useCallback((e: WheelEvent) => {
     requestAnimationFrame(() => {
       setViewState(prev => ({ ...prev, scale: newScale }))
     })
   }, [])
   ```

### 10.3 Bundle Optimization

Expected Visx imports and sizes (estimates - verify during Story 3.1):
| Package | Size (gzip) |
|---------|-------------|
| @visx/scale | ~3KB |
| @visx/axis | ~5KB |
| @visx/shape | ~4KB |
| @visx/group | ~1KB |
| @visx/tooltip | ~2KB |
| @visx/responsive | ~1KB |
| **Total** | **~16KB** |

Motion library: ~15KB gzipped

**Bundle Size Verification (Story 3.1 Requirement):**
After implementing Story 3.1, run the following to verify actual bundle sizes:
```bash
# Build and analyze bundle
pnpm build
# Check visualization chunk size in .next/static/chunks
ls -lh .next/static/chunks/*.js | grep -E "(visualization|visx|motion)"
# Or use next-bundle-analyzer if configured
```
Verify total visualization bundle remains under 50KB gzipped target.
If actual sizes exceed estimates by >20%, document findings and consider:
1. More aggressive tree-shaking
2. Dynamic imports for non-critical features
3. Lighter alternatives for specific packages

---

## 11. Traceability Matrix

### 11.1 FR to Story Mapping

| FR | Story | Components | Tests |
|----|-------|------------|-------|
| FR7 | 3.1, 3.2 | ScatterPlot, ScatterPoint | scatter-plot.test.tsx, timeline.spec.ts |
| FR8 | 3.3 | ScatterPlot (pan handlers) | timeline.spec.ts |
| FR9 | 3.4 | ScatterPlot, ZoomControls, useZoom | use-zoom.test.ts, timeline.spec.ts |
| FR10 | 3.5 | ClusterBadge, clustering.ts | clustering.test.ts |
| FR11 | 3.6 | TooltipCard | timeline.spec.ts |
| FR12 | 3.7 | ObituaryModal | timeline.spec.ts |
| FR46 | 3.8 | All visualization components | Performance profiling |
| FR47 | 3.8 | animation.ts, Motion usage | Performance profiling |

### 11.2 Component to Test Mapping

| Component | Unit Tests | Integration Tests | E2E Tests |
|-----------|------------|-------------------|-----------|
| ScatterPlot | - | scatter-plot.test.tsx | timeline.spec.ts |
| ScatterPoint | scatter-point.test.tsx | - | timeline.spec.ts |
| TooltipCard | - | - | timeline.spec.ts |
| ZoomControls | - | - | timeline.spec.ts |
| ClusterBadge | - | - | - |
| ObituaryModal | - | - | timeline.spec.ts |
| scatter-helpers.ts | scatter-helpers.test.ts | - | - |
| clustering.ts | clustering.test.ts | - | - |
| use-zoom.ts | use-zoom.test.ts | - | - |

---

## 12. Risks and Mitigations

### 12.1 Technical Risks

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Visx learning curve | Medium | Medium | Start with simple scatter, add features incrementally |
| Performance with 200+ dots | High | Medium | Profile early, implement virtualization if needed |
| Touch gesture conflicts | Medium | Medium | Test on real devices early, use established gesture libraries |
| SVG vs Canvas tradeoffs | Medium | Low | SVG chosen for accessibility; monitor performance |
| Animation jank | High | Medium | Use will-change sparingly, profile with DevTools |

### 12.2 Dependency Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| Visx breaking changes | Medium | Pin version, test before updating |
| Motion API changes | Medium | Pin version, follow migration guides |
| Browser compatibility | Low | Modern browsers only, tested with Playwright |

---

## 13. Open Questions

1. **Contextual Y-Axis (Future):** Should we implement market/capability Y-axis modes in Epic 3, or defer to a future epic?
   - **Recommendation:** Defer. Focus on "spread" mode for MVP. Contextual axes require additional data and complexity.

2. **Mobile Timeline:** Should the scatter plot remain on mobile, or switch to density bar?
   - **Answer:** Epic 5 handles mobile view. Epic 3 focuses on desktop/tablet scatter plot.

3. **Cluster Interaction:** When clicking a cluster, zoom in or show list of obituaries?
   - **Recommendation:** Zoom in to reveal individual dots. This encourages exploration.

4. **Tooltip vs Modal:** Should hover show tooltip AND click show modal, or just one?
   - **Answer:** Both. Tooltip for quick preview (hover), modal for full details (click).

---

## 14. Implementation Order

**Recommended Story Sequence:**

1. **Story 3.1: Scatter Plot Foundation** - Sets up container, scales, basic render
2. **Story 3.2: Timeline Data Points** - Adds dots with category colors
3. **Story 3.6: Hover Tooltips** - Quick win for interactivity
4. **Story 3.3: Horizontal Scroll/Pan** - Navigation
5. **Story 3.4: Zoom Functionality** - Scale exploration
6. **Story 3.7: Click to Modal** - Deep dive into obituaries
7. **Story 3.5: Density Visualization** - Polish for clusters
8. **Story 3.8: Animation Polish** - Performance and reduced motion

---

## 15. Summary

Epic 3 delivers the core visual experience of AI Obituaries - an interactive scatter plot timeline that transforms a list of skepticism claims into a compelling visual narrative. The implementation uses Visx for precise SVG control, Motion for smooth 60fps animations, and follows established patterns from the architecture document.

**Key Deliverables:**
- Interactive scatter plot with category-colored dots
- Pan and zoom navigation
- Hover tooltips with claim preview
- Click-to-modal for full obituary details
- Density visualization for clusters
- 60fps performance with 200+ data points
- Reduced motion support for accessibility

**Success Criteria:**
- All 8 FRs (FR7-FR12, FR46-FR47) implemented
- Performance targets met (60fps, <50ms hover response)
- E2E tests passing for core interactions
- Lighthouse performance score maintained

---

_Generated by Epic Tech Context Specialist_
_Date: 2025-11-30_
_For: Luca_

---

**Document incorporates context from:**
- [PRD](../../prd.md) - Functional Requirements FR7-FR12, FR46-FR47
- [Architecture](../../architecture.md) - Visx, Motion, Contextual Scatter Plot pattern
- [Epics](../../epics.md) - Epic 3 stories and acceptance criteria
